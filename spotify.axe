{
  "manifest": {
    "id": "spotify",
    "name": "Spotify",
    "version": "1.1.0",
    "author": "Parachord Team",
    "description": "Stream from Spotify via Spotify Connect API. Requires Spotify Premium for remote playback.",
    "icon": "â™«",
    "color": "#1DB954",
    "homepage": "https://spotify.com",
    "email": "support@harmonix.app"
  },
  "capabilities": {
    "resolve": true,
    "search": true,
    "stream": true,
    "browse": false,
    "urlLookup": true
  },
  "urlPatterns": [
    "open.spotify.com/track/*",
    "open.spotify.com/album/*",
    "open.spotify.com/playlist/*",
    "open.spotify.com/intl-*/track/*",
    "open.spotify.com/intl-*/album/*",
    "open.spotify.com/intl-*/playlist/*",
    "spotify:track:*",
    "spotify:album:*",
    "spotify:playlist:*"
  ],
  "settings": {
    "requiresAuth": true,
    "authType": "oauth",
    "scopes": [
      "user-read-playback-state",
      "user-modify-playback-state",
      "user-read-currently-playing"
    ],
    "configurable": {
      "clientId": {
        "type": "text",
        "label": "Client ID",
        "placeholder": "Your Spotify Client ID",
        "required": true,
        "helpUrl": "https://developer.spotify.com/dashboard"
      }
    }
  },
  "implementation": {
    "search": "async function(query, config) { if (!config.token) return []; const doSearch = async (token) => { const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=20`, { headers: { 'Authorization': `Bearer ${token}` } }); if (!response.ok) { let body = ''; try { body = await response.text(); } catch(e) {} console.error('Spotify search failed:', response.status, body); return { ok: false, status: response.status }; } const data = await response.json(); return { ok: true, items: data.tracks.items }; }; try { let result = await doSearch(config.token); if (!result.ok && (result.status === 400 || result.status === 401) && config.refreshToken) { console.log('ðŸ”„ Spotify: Token may be invalid, forcing refresh...'); const newToken = await config.refreshToken(); if (newToken && newToken !== config.token) { console.log('ðŸ”„ Spotify: Retrying search with refreshed token'); result = await doSearch(newToken); } } if (!result.ok) return []; return result.items.map(track => ({ id: `spotify-${track.id}`, title: track.name, artist: track.artists.map(a => a.name).join(', '), album: track.album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, spotifyAlbumId: track.album.id, albumArt: track.album.images[0]?.url })); } catch (error) { console.error('Spotify search error:', error); return []; } }",
    "resolve": "async function(artist, track, album, config) { const query = `artist:${artist} track:${track}`; const results = await this.search(query, config); return results[0] || null; }",
    "lookupUrl": "async function(url, config) { if (!config.token) return null; try { console.log('Spotify URL lookup:', url); var trackId = null; var m = url.match(/\\/track\\/([a-zA-Z0-9]+)/); if (m) trackId = m[1]; if (!trackId) { m = url.match(/spotify:track:([a-zA-Z0-9]+)/); if (m) trackId = m[1]; } if (!trackId) { console.log('Could not extract track ID from URL'); return null; } const response = await fetch('https://api.spotify.com/v1/tracks/' + trackId, { headers: { 'Authorization': 'Bearer ' + config.token } }); if (!response.ok) { console.error('Spotify track lookup failed:', response.status); return null; } const track = await response.json(); return { id: 'spotify-' + track.id, title: track.name, artist: track.artists.map(function(a) { return a.name; }).join(', '), album: track.album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, spotifyAlbumId: track.album.id, albumArt: track.album.images[0] ? track.album.images[0].url : null }; } catch (error) { console.error('Spotify URL lookup error:', error); return null; } }",
    "lookupAlbum": "async function(url, config) { if (!config.token) return null; try { console.log('Spotify album lookup:', url); var albumId = null; var m = url.match(/\\/album\\/([a-zA-Z0-9]+)/); if (m) albumId = m[1]; if (!albumId) { m = url.match(/spotify:album:([a-zA-Z0-9]+)/); if (m) albumId = m[1]; } if (!albumId) { console.log('Could not extract album ID from URL'); return null; } const albumResponse = await fetch('https://api.spotify.com/v1/albums/' + albumId, { headers: { 'Authorization': 'Bearer ' + config.token } }); if (!albumResponse.ok) { console.error('Spotify album lookup failed:', albumResponse.status); return null; } const album = await albumResponse.json(); var tracks = album.tracks.items.map(function(track) { return { id: 'spotify-' + track.id, title: track.name, artist: track.artists.map(function(a) { return a.name; }).join(', '), album: album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, spotifyAlbumId: album.id, albumArt: album.images[0] ? album.images[0].url : null, trackNumber: track.track_number, discNumber: track.disc_number }; }); tracks.sort(function(a, b) { if (a.discNumber !== b.discNumber) return a.discNumber - b.discNumber; return a.trackNumber - b.trackNumber; }); return { id: 'spotify-album-' + albumId, name: album.name, artist: album.artists.map(function(a) { return a.name; }).join(', '), albumArt: album.images[0] ? album.images[0].url : null, releaseDate: album.release_date, trackCount: album.total_tracks, tracks: tracks, url: url }; } catch (error) { console.error('Spotify album lookup error:', error); return null; } }",
    "lookupPlaylist": "async function(url, config) { if (!config.token) return null; try { console.log('Spotify playlist lookup:', url); var playlistId = null; var m = url.match(/\\/playlist\\/([a-zA-Z0-9]+)/); if (m) playlistId = m[1]; if (!playlistId) { m = url.match(/spotify:playlist:([a-zA-Z0-9]+)/); if (m) playlistId = m[1]; } if (!playlistId) { console.log('Could not extract playlist ID from URL'); return null; } var allTracks = []; var nextUrl = 'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks?limit=100'; var playlistName = ''; var playlistImage = null; var playlistResp = await fetch('https://api.spotify.com/v1/playlists/' + playlistId + '?fields=name,images', { headers: { 'Authorization': 'Bearer ' + config.token } }); if (playlistResp.ok) { var playlistData = await playlistResp.json(); playlistName = playlistData.name || ''; playlistImage = playlistData.images && playlistData.images[0] ? playlistData.images[0].url : null; } while (nextUrl) { var response = await fetch(nextUrl, { headers: { 'Authorization': 'Bearer ' + config.token } }); if (!response.ok) { console.error('Spotify playlist tracks fetch failed:', response.status); break; } var data = await response.json(); var items = data.items || []; for (var i = 0; i < items.length; i++) { var item = items[i]; if (!item.track || item.track.type !== 'track') continue; var track = item.track; allTracks.push({ id: 'spotify-' + track.id, title: track.name, artist: track.artists.map(function(a) { return a.name; }).join(', '), album: track.album.name, duration: Math.floor(track.duration_ms / 1000), sources: ['spotify'], spotifyUri: track.uri, spotifyId: track.id, spotifyAlbumId: track.album.id, albumArt: track.album.images[0] ? track.album.images[0].url : null }); } nextUrl = data.next; } console.log('Spotify playlist loaded:', playlistName, '(' + allTracks.length + ' tracks)'); return { id: 'spotify-playlist-' + playlistId, name: playlistName, albumArt: playlistImage, trackCount: allTracks.length, tracks: allTracks, url: url }; } catch (error) { console.error('Spotify playlist lookup error:', error); return null; } }",
    "play": "async function(track, config) { if (!config.token) { console.error('Spotify not connected'); return false; } try { const devicesResponse = await fetch('https://api.spotify.com/v1/me/player/devices', { headers: { 'Authorization': `Bearer ${config.token}` } }); if (!devicesResponse.ok) return false; const devicesData = await devicesResponse.json(); const devices = devicesData.devices || []; if (devices.length === 0) { console.error('No Spotify devices found'); return false; } const controllable = devices.filter(d => !d.is_restricted); const available = controllable.length > 0 ? controllable : devices; const computer = available.find(d => d.type === 'Computer'); const phone = available.find(d => d.type === 'Smartphone'); const speaker = available.find(d => d.type === 'Speaker'); const nonWebActive = available.find(d => d.is_active && !d.name.toLowerCase().includes('web')); const nonWeb = available.find(d => !d.name.toLowerCase().includes('web')); let activeDevice = computer || phone || speaker || nonWebActive || nonWeb || available[0]; console.log('Selected device:', activeDevice.name, activeDevice.type); if (!activeDevice.is_active) { const transferResponse = await fetch('https://api.spotify.com/v1/me/player', { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ device_ids: [activeDevice.id], play: true }) }); if (!transferResponse.ok && transferResponse.status !== 204) { console.error('Failed to transfer playback'); } await new Promise(resolve => setTimeout(resolve, 1000)); } const playResponse = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${activeDevice.id}`, { method: 'PUT', headers: { 'Authorization': `Bearer ${config.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ uris: [track.spotifyUri] }) }); return playResponse.ok || playResponse.status === 204; } catch (error) { console.error('Spotify play error:', error); return false; } }",
    "init": "async function(config) { console.log('Spotify resolver initialized'); }",
    "cleanup": "async function() { console.log('Spotify resolver cleanup'); }"
  }
}
