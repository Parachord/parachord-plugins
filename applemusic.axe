{
  "_comment": [
    "FULL PLAYBACK SUPPORT VIA MUSICKIT",
    "To enable direct Apple Music playback, you would need:",
    "1. Apple Developer Program membership ($99/year)",
    "2. Create a MusicKit identifier in the Apple Developer portal",
    "3. Generate a private key (.p8 file) for signing tokens",
    "4. Create a Developer Token (JWT signed with the private key)",
    "   - Header: { alg: 'ES256', kid: '<your-key-id>' }",
    "   - Payload: { iss: '<team-id>', iat: <now>, exp: <+6months> }",
    "5. Include MusicKit JS in the app: https://js-cdn.music.apple.com/musickit/v3/musickit.js",
    "6. Initialize with: MusicKit.configure({ developerToken: '<jwt>', app: { name: 'Parachord' } })",
    "7. User authorization: await music.authorize() - prompts user to sign in",
    "8. Playback: await music.setQueue({ song: '<apple-music-id>' }); await music.play()",
    "See: https://developer.apple.com/documentation/musickitjs"
  ],

  "manifest": {
    "id": "applemusic",
    "name": "Apple Music",
    "type": "meta-service",
    "version": "1.0.0",
    "author": "Parachord Team",
    "description": "Search and identify tracks via iTunes/Apple Music catalog. Streaming support coming soon.",
    "icon": "üçé",
    "color": "#FA243C",
    "homepage": "https://music.apple.com",
    "email": "support@parachord.com"
  },

  "capabilities": {
    "search": true,
    "metadata": true,
    "urlLookup": true
  },

  "urlPatterns": [
    "music.apple.com/*/album/*",
    "music.apple.com/*/album/*/*",
    "music.apple.com/*/song/*",
    "music.apple.com/*/song/*/*",
    "music.apple.com/*/playlist/*",
    "music.apple.com/*/playlist/*/*",
    "itunes.apple.com/*/album/*",
    "itunes.apple.com/*/album/*/*"
  ],

  "settings": {
    "requiresAuth": false,
    "authType": "none",
    "configurable": {}
  },

  "implementation": {
    "search": "async function(query, config) { try { console.log('Searching Apple Music for:', query); const response = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&media=music&entity=song&limit=20`); if (!response.ok) { console.error('Apple Music search failed:', response.status); return []; } const data = await response.json(); if (!data.results || data.results.length === 0) { console.log('No Apple Music results found'); return []; } const results = data.results.map(track => ({ id: `applemusic-${track.trackId}`, title: track.trackName, artist: track.artistName, album: track.collectionName, duration: Math.floor(track.trackTimeMillis / 1000), sources: ['applemusic'], appleMusicId: track.trackId, appleMusicUrl: track.trackViewUrl, albumArt: track.artworkUrl100 ? track.artworkUrl100.replace('100x100', '300x300') : null, previewUrl: track.previewUrl, isStreamable: track.isStreamable })); console.log(`Found ${results.length} Apple Music results`); return results; } catch (error) { console.error('Apple Music search error:', error); return []; } }",

    "resolve": "async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }",

    "init": "async function(config) { console.log('Apple Music resolver initialized'); }",

    "cleanup": "async function() { console.log('Apple Music resolver cleanup'); }",

    "lookupUrl": "async function(url, config) { try { let trackId = null; const trackParamMatch = url.match(/[?&]i=([0-9]+)/); if (trackParamMatch) { trackId = trackParamMatch[1]; } else { const songMatch = url.match(/\\/song\\/[^/]+\\/([0-9]+)/); if (songMatch) { trackId = songMatch[1]; } } if (!trackId) { console.log('Apple Music URL lookup: Could not extract track ID from', url); return null; } const response = await fetch(`https://itunes.apple.com/lookup?id=${trackId}&entity=song`); if (!response.ok) return null; const data = await response.json(); if (!data.results || data.results.length === 0) return null; const track = data.results.find(r => r.wrapperType === 'track') || data.results[0]; if (!track || track.wrapperType !== 'track') return null; return { title: track.trackName, artist: track.artistName, album: track.collectionName, duration: Math.floor(track.trackTimeMillis / 1000), albumArt: track.artworkUrl100 ? track.artworkUrl100.replace('100x100', '300x300') : null, sourceUrl: url, appleMusicId: track.trackId, appleMusicUrl: track.trackViewUrl, previewUrl: track.previewUrl }; } catch (error) { console.error('Apple Music URL lookup error:', error); return null; } }",

    "lookupAlbum": "async function(url, config) { try { let albumId = null; const albumMatch = url.match(/\\/album\\/[^/]+\\/([0-9]+)/); if (albumMatch) { albumId = albumMatch[1]; } if (!albumId) { console.log('Apple Music album lookup: Could not extract album ID from', url); return null; } const response = await fetch(`https://itunes.apple.com/lookup?id=${albumId}&entity=song`); if (!response.ok) return null; const data = await response.json(); if (!data.results || data.results.length === 0) return null; const albumInfo = data.results.find(r => r.wrapperType === 'collection'); const trackItems = data.results.filter(r => r.wrapperType === 'track'); if (!albumInfo || trackItems.length === 0) return null; const tracks = trackItems.map(track => ({ title: track.trackName, artist: track.artistName, album: track.collectionName, duration: Math.floor(track.trackTimeMillis / 1000), albumArt: track.artworkUrl100 ? track.artworkUrl100.replace('100x100', '300x300') : null, appleMusicId: track.trackId, appleMusicUrl: track.trackViewUrl, previewUrl: track.previewUrl })); return { type: 'album', name: albumInfo.collectionName, artist: albumInfo.artistName, albumArt: albumInfo.artworkUrl100 ? albumInfo.artworkUrl100.replace('100x100', '300x300') : null, tracks: tracks }; } catch (error) { console.error('Apple Music album lookup error:', error); return null; } }",

    "lookupPlaylist": "async function(url, config) { console.log('üçé Apple Music lookupPlaylist called with:', url); try { const playlistIdMatch = url.match(/\\/playlist\\/[^/]+\\/(pl\\.[a-zA-Z0-9-]+)/); if (!playlistIdMatch) { console.log('Could not extract playlist ID from URL:', url); return null; } const playlistId = playlistIdMatch[1]; console.log('üçé Playlist ID:', playlistId); let html = null; const fetchFn = window.electron?.proxyFetch ? async (u) => { const r = await window.electron.proxyFetch(u); return r.success ? r.text : null; } : async (u) => { const r = await fetch(u, { headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' } }); return r.ok ? r.text() : null; }; html = await fetchFn(url); if (!html) { console.log('üçé Failed to fetch Apple Music playlist page'); return null; } console.log('üçé Got HTML, length:', html.length); const tracks = []; let playlistName = 'Apple Music Playlist'; let playlistArt = null; const titleMatch = html.match(/<title>([^<]+)<\\/title>/); if (titleMatch) { playlistName = titleMatch[1].replace(/ - Apple Music$/, '').replace(/ on Apple Music$/, '').trim(); console.log('üçé Playlist name:', playlistName); } const ogImageMatch = html.match(/<meta[^>]*property=\\\"og:image\\\"[^>]*content=\\\"([^\\\"]+)\\\"/); if (ogImageMatch) { playlistArt = ogImageMatch[1]; console.log('üçé Found playlist art'); } const hasSerializedScript = html.includes('serialized-server-data'); console.log('üçé Has serialized-server-data:', hasSerializedScript); const scriptMatch = html.match(/<script[^>]*id=\\\"serialized-server-data\\\"[^>]*>([^<]+)<\\/script>/); console.log('üçé Script match found:', !!scriptMatch); if (scriptMatch) { try { const base64Data = scriptMatch[1]; console.log('üçé Base64 data length:', base64Data.length, 'first 50 chars:', base64Data.substring(0, 50)); const jsonStr = atob(base64Data); console.log('üçé Decoded JSON length:', jsonStr.length); const data = JSON.parse(jsonStr); console.log('üçé Parsed JSON, type:', typeof data, 'isArray:', Array.isArray(data)); const findTracks = (obj, depth = 0) => { if (depth > 15 || tracks.length >= 200) return; if (!obj || typeof obj !== 'object') return; if (Array.isArray(obj)) { for (const item of obj) { findTracks(item, depth + 1); } } else { if (obj.type === 'songs' && obj.attributes) { const attrs = obj.attributes; if (attrs.name && attrs.artistName) { const isDuplicate = tracks.some(t => t.title === attrs.name && t.artist === attrs.artistName); if (!isDuplicate) { tracks.push({ title: attrs.name, artist: attrs.artistName, album: attrs.albumName || playlistName, duration: attrs.durationInMillis ? Math.floor(attrs.durationInMillis / 1000) : 180, albumArt: attrs.artwork?.url?.replace('{w}', '300').replace('{h}', '300') || playlistArt }); } } } for (const key of Object.keys(obj)) { findTracks(obj[key], depth + 1); } } }; findTracks(data); console.log('üçé Found', tracks.length, 'tracks from serialized data'); } catch (parseErr) { console.log('üçé Failed to parse serialized data:', parseErr.message); } } else { console.log('üçé No serialized-server-data script found, trying alternate patterns'); const altScriptMatch = html.match(/<script[^>]*id=['\"]serialized-server-data['\"][^>]*>([\\s\\S]*?)<\\/script>/); console.log('üçé Alternate script match:', !!altScriptMatch); } if (tracks.length === 0) { console.log('üçé Trying regex fallback on raw HTML...'); const trackPattern = /\\\"name\\\":\\s*\\\"([^\\\"]+)\\\"[\\s\\S]{0,200}?\\\"artistName\\\":\\s*\\\"([^\\\"]+)\\\"/g; let match; while ((match = trackPattern.exec(html)) !== null && tracks.length < 200) { const [, title, artist] = match; if (title && artist && title.length < 100 && artist.length < 100 && !title.includes('\\\\u')) { const isDuplicate = tracks.some(t => t.title === title && t.artist === artist); if (!isDuplicate) { tracks.push({ title, artist, album: playlistName, duration: 180, albumArt: playlistArt }); } } } console.log('üçé Regex fallback found', tracks.length, 'tracks'); } if (tracks.length === 0) { console.log('üçé No tracks found, returning null'); return null; } console.log('üçé Returning playlist with', tracks.length, 'tracks'); return { type: 'playlist', name: playlistName, albumArt: playlistArt, tracks: tracks }; } catch (error) { console.error('üçé Apple Music playlist lookup error:', error); return null; } }"
  }
}
