{
  "manifest": {
    "id": "gemini",
    "name": "Google Gemini",
    "type": "meta-service",
    "version": "1.0.0",
    "author": "Parachord Team",
    "description": "Generate playlists using Google Gemini. Requires your own API key.",
    "icon": "✦",
    "color": "#4285f4",
    "homepage": "https://ai.google.dev"
  },

  "capabilities": {
    "generate": true
  },

  "settings": {
    "requiresAuth": true,
    "authType": "apiKey",
    "configurable": {
      "apiKey": {
        "type": "password",
        "label": "API Key",
        "placeholder": "AIza...",
        "helpUrl": "https://aistudio.google.com/app/apikey"
      },
      "model": {
        "type": "select",
        "label": "Model",
        "default": "gemini-2.5-flash",
        "options": [
          { "value": "gemini-2.5-flash", "label": "Gemini 2.5 Flash (Recommended)" },
          { "value": "gemini-2.5-pro", "label": "Gemini 2.5 Pro" }
        ]
      }
    }
  },

  "implementation": {
    "generate": "async function(prompt, config, listeningContext) { if (!config.apiKey) { throw new Error('API key required. Add your Google API key in Settings → General → AI Integration.'); } try { const model = config.model || 'gemini-2.5-flash'; let fullPrompt = 'You are a music recommendation assistant. Given a prompt and optionally the user\\'s listening history, return ONLY a valid JSON object (no markdown, no code blocks, no explanation) with a \"tracks\" array containing 10-15 track recommendations. Each track must have \"artist\" and \"title\" fields. When listening history is provided, use it to understand the user\\'s taste but don\\'t just recommend what they already listen to. Find tracks that complement their taste while honoring the prompt. Prioritize discovery over familiarity.\\n\\nExample response format:\\n{\"tracks\": [{\"artist\": \"Artist Name\", \"title\": \"Song Title\"}]}\\n\\n'; if (listeningContext) { fullPrompt += `User\\'s listening history (${listeningContext.window}):\\n\\nTop Artists: ${listeningContext.top_artists.join(', ')}\\n\\nTop Tracks:\\n${listeningContext.top_tracks.map(t => `- ${t.artist} - ${t.title}`).join('\\n')}\\n\\n---\\n\\n`; } fullPrompt += 'Prompt: ' + prompt; const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${config.apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { responseMimeType: 'application/json' } }) }); if (!response.ok) { const error = await response.json().catch(() => ({})); if (response.status === 400 && error.error?.message?.includes('API key')) { throw new Error('Invalid API key. Check your Google API key in Settings.'); } if (response.status === 403) { throw new Error('API access denied. Check your API key permissions at ai.google.dev.'); } if (response.status === 429) { throw new Error('Daily quota exceeded. Gemini\\'s free tier allows ~25-50 requests/day. Try again tomorrow or upgrade at ai.google.dev.'); } if (response.status >= 500) { throw new Error('AI service temporarily unavailable. Try again later.'); } throw new Error(error.error?.message || 'Gemini API request failed'); } const data = await response.json(); let content = data.candidates?.[0]?.content?.parts?.[0]?.text; if (!content) { throw new Error('No response from Gemini'); } content = content.trim(); if (content.startsWith('```json')) { content = content.slice(7); } else if (content.startsWith('```')) { content = content.slice(3); } if (content.endsWith('```')) { content = content.slice(0, -3); } content = content.trim(); const jsonMatch = content.match(/\\{[\\s\\S]*\\}/); if (jsonMatch) { content = jsonMatch[0]; } const parsed = JSON.parse(content); const tracks = parsed.tracks || parsed.playlist || parsed.songs || []; if (!Array.isArray(tracks) || tracks.length === 0) { throw new Error('AI returned no tracks. Try a different prompt.'); } return tracks.map(t => ({ artist: t.artist || t.Artist || '', title: t.title || t.track || t.song || t.Title || '' })).filter(t => t.artist && t.title); } catch (error) { if (error.message.includes('API key') || error.message.includes('Rate limit') || error.message.includes('quota') || error.message.includes('No response') || error.message.includes('no tracks') || error.message.includes('access denied') || error.message.includes('unavailable')) { throw error; } console.error('Gemini generate error:', error); throw new Error('Failed to generate playlist: ' + error.message); } }",

    "init": "async function(config) { console.log('Gemini plugin initialized'); }",

    "cleanup": "async function() { console.log('Gemini plugin cleanup'); }"
  }
}
