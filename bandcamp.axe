{
  "manifest": {
    "id": "bandcamp",
    "name": "Bandcamp",
    "version": "1.2.0",
    "author": "Parachord Team",
    "description": "Find and purchase music on Bandcamp. Plays tracks in embedded player with autoplay.",
    "icon": "ðŸŽ¸",
    "color": "#629AA9",
    "homepage": "https://bandcamp.com",
    "email": "support@parachord.com"
  },

  "capabilities": {
    "resolve": true,
    "search": true,
    "stream": false,
    "browse": false,
    "urlLookup": true
  },

  "urlPatterns": [
    "*.bandcamp.com/track/*",
    "*.bandcamp.com/album/*"
  ],

  "settings": {
    "requiresAuth": false,
    "authType": "none",
    "configurable": {}
  },

  "implementation": {
    "search": "async function(query, config) { try { console.log('Searching Bandcamp for:', query); const response = await fetch(`https://bandcamp.com/search?q=${encodeURIComponent(query)}&item_type=t`, { method: 'GET', headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' } }); if (!response.ok) { console.error('Bandcamp search failed:', response.status); return []; } const html = await response.text(); const results = []; const parser = new DOMParser(); const doc = parser.parseFromString(html, 'text/html'); const searchResults = doc.querySelectorAll('.searchresult'); searchResults.forEach((item, index) => { if (index >= 20) return; try { const heading = item.querySelector('.heading'); const subhead = item.querySelector('.subhead'); const itemUrl = item.querySelector('.itemurl'); if (heading && itemUrl) { const title = heading.textContent.trim(); const artistInfo = subhead ? subhead.textContent.trim() : 'Unknown Artist'; const byMatch = artistInfo.match(/by\\s+([^,]+)/); const fromMatch = artistInfo.match(/from\\s+(.+)/); const artist = byMatch ? byMatch[1].trim() : 'Unknown Artist'; const album = fromMatch ? fromMatch[1].trim() : (byMatch ? byMatch[1].trim() : 'Single'); const url = itemUrl.textContent.trim(); results.push({ id: `bandcamp-${Date.now()}-${index}`, title: title, artist: artist, album: album, duration: 210, sources: ['bandcamp'], bandcampUrl: url }); } } catch (itemError) { console.error('Error parsing Bandcamp result:', itemError); } }); console.log(`Found ${results.length} Bandcamp results`); return results; } catch (error) { console.error('Bandcamp search error:', error); return []; } }",

    "resolve": "async function(artist, track, album, config) { const query = `${artist} ${track}`; const results = await this.search(query, config); return results[0] || null; }",

    "play": "async function(track, config) { if (!track.bandcampUrl) { console.error('No Bandcamp URL found'); return false; } try { let trackId = track.bandcampTrackId; let bandcampUrl = track.bandcampUrl; if (!bandcampUrl.startsWith('http')) { bandcampUrl = 'https://' + bandcampUrl; } console.log('Bandcamp play - trackId:', trackId, 'url:', bandcampUrl, 'hasPlaybackWindow:', !!window.electron?.playbackWindow); if (!trackId && window.electron?.proxyFetch) { console.log('No track ID cached, fetching via proxy...'); try { const result = await window.electron.proxyFetch(bandcampUrl); if (result.success && result.text) { const trackIdMatch = result.text.match(/track_id(?:\"|&quot;):(\\d+)/); if (trackIdMatch) { trackId = trackIdMatch[1]; console.log('Found track ID via proxy:', trackId); } } } catch (fetchErr) { console.log('Proxy fetch failed:', fetchErr); } } if (trackId && window.electron?.playbackWindow) { const embedUrl = `https://bandcamp.com/EmbeddedPlayer/track=${trackId}/size=large/bgcol=1a1a2e/linkcol=e99708/tracklist=false/artwork=small/transparent=true/autoplay=true/`; console.log('Opening Bandcamp embed in playback window:', embedUrl); await window.electron.playbackWindow.open(embedUrl, { title: `${track.title} - ${track.artist}`, width: 350, height: 120 }); return true; } console.log('No track ID found, falling back to browser extension'); if (window.electron?.extension) { await window.electron.shell.openExternal(bandcampUrl); return true; } console.log('Falling back to external browser for Bandcamp'); if (window.electron?.shell?.openExternal) { const result = await window.electron.shell.openExternal(bandcampUrl); return result && result.success; } else { const newWindow = window.open(bandcampUrl, '_blank'); return !!newWindow; } } catch (error) { console.error('Failed to play Bandcamp track:', error); return false; } }",

    "init": "async function(config) { console.log('Bandcamp resolver initialized'); }",

    "cleanup": "async function() { console.log('Bandcamp resolver cleanup'); if (window.electron?.playbackWindow) { await window.electron.playbackWindow.close(); } }",

    "lookupUrl": "async function(url, config) { try { const response = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' } }); if (!response.ok) return null; const html = await response.text(); const parser = new DOMParser(); const doc = parser.parseFromString(html, 'text/html'); let title = '', artist = '', album = '', duration = 0, albumArt = '', trackId = null; const trackIdMatch = html.match(/track_id(?:\"|&quot;):(\\d+)/); if (trackIdMatch) { trackId = trackIdMatch[1]; } const ldJson = doc.querySelector('script[type=\"application/ld+json\"]'); if (ldJson) { try { const data = JSON.parse(ldJson.textContent); title = data.name || ''; if (data.byArtist) artist = data.byArtist.name || ''; if (data.inAlbum) album = data.inAlbum.name || ''; if (data.duration) { const match = data.duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/); if (match) { duration = (parseInt(match[1] || 0) * 3600) + (parseInt(match[2] || 0) * 60) + parseInt(match[3] || 0); } } } catch (e) { console.error('Failed to parse ld+json:', e); } } if (!title) { const titleEl = doc.querySelector('.trackTitle'); if (titleEl) title = titleEl.textContent.trim(); } if (!artist) { const artistEl = doc.querySelector('#name-section h3 span a'); if (artistEl) artist = artistEl.textContent.trim(); } if (!album) { const albumEl = doc.querySelector('#name-section h3:nth-child(3) span a'); if (albumEl) album = albumEl.textContent.trim(); } const artEl = doc.querySelector('#tralbumArt img'); if (artEl) albumArt = artEl.src; if (!title) return null; return { title, artist: artist || 'Unknown Artist', album: album || 'Single', duration: duration || 210, albumArt, sourceUrl: url, bandcampUrl: url, bandcampTrackId: trackId }; } catch (error) { console.error('Bandcamp URL lookup error:', error); return null; } }",

    "lookupAlbum": "async function(url, config) { try { const response = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36' } }); if (!response.ok) return null; const html = await response.text(); const parser = new DOMParser(); const doc = parser.parseFromString(html, 'text/html'); let albumName = '', artist = '', albumArt = ''; const tracks = []; const ldJsonEl = doc.querySelector('script[type=\"application/ld+json\"]'); if (ldJsonEl) { try { const data = JSON.parse(ldJsonEl.textContent); if (data['@type'] === 'MusicAlbum') { albumName = data.name || ''; if (data.byArtist) artist = data.byArtist.name || ''; if (data.image) albumArt = data.image; if (data.track && data.track.itemListElement) { data.track.itemListElement.forEach(item => { const trackData = item.item || item; let duration = 0; if (trackData.duration) { const match = trackData.duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/); if (match) { duration = (parseInt(match[1] || 0) * 3600) + (parseInt(match[2] || 0) * 60) + parseInt(match[3] || 0); } } let trackId = null; if (trackData['@id']) { const idMatch = trackData['@id'].match(/track_id=(\\d+)/); if (idMatch) trackId = idMatch[1]; } tracks.push({ title: trackData.name || 'Unknown Track', artist: artist, album: albumName, duration: duration || 210, albumArt: albumArt, bandcampUrl: trackData.url || url, bandcampTrackId: trackId }); }); } } } catch (e) { console.error('Failed to parse Bandcamp album ld+json:', e); } } if (!albumName) { const titleEl = doc.querySelector('#name-section h2.trackTitle'); if (titleEl) albumName = titleEl.textContent.trim(); } if (!artist) { const artistEl = doc.querySelector('#name-section h3 span a'); if (artistEl) artist = artistEl.textContent.trim(); } if (!albumArt) { const artEl = doc.querySelector('#tralbumArt img'); if (artEl) albumArt = artEl.src; } if (tracks.length === 0) { const trackTable = doc.querySelectorAll('table#track_table tr.track_row_view'); trackTable.forEach(row => { const titleEl = row.querySelector('.track-title'); const durationEl = row.querySelector('.time'); const linkEl = row.querySelector('a'); if (titleEl) { let duration = 210; if (durationEl) { const timeText = durationEl.textContent.trim(); const timeParts = timeText.split(':'); if (timeParts.length === 2) { duration = parseInt(timeParts[0]) * 60 + parseInt(timeParts[1]); } } let trackUrl = url; if (linkEl && linkEl.href) { trackUrl = linkEl.href; } tracks.push({ title: titleEl.textContent.trim(), artist: artist || 'Unknown Artist', album: albumName || 'Unknown Album', duration: duration, albumArt: albumArt, bandcampUrl: trackUrl }); } }); } if (tracks.length === 0) return null; return { type: 'album', name: albumName || 'Unknown Album', artist: artist || 'Unknown Artist', albumArt: albumArt, tracks: tracks }; } catch (error) { console.error('Bandcamp album lookup error:', error); return null; } }"
  }
}
